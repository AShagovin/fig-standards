Common Interface for Caching libraries
================

This document describes a simple yet extensible interface for a cache item and
a cache driver.

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD",
"SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be
interpreted as described in [RFC 2119][].

The final implementations MAY be able to decorate the objects with more
functionality than the one proposed but they MUST implement the indicated
interfaces/functionality first.

[RFC 2119]: http://tools.ietf.org/html/rfc2119

1. Specification
-----------------

## 1.1 Introduction

Caching is a common way to improve the performance of any project, making
caching libraries one of the most common features of many frameworks and
libraries. This has led to a situation where many libraries roll their own
caching libraries, with various levels of functionality. These differences are
causing developers to have to learn multiple systems which may or may not
provide the functionality they need. In addition, the developers of caching
libraries themselves face a choice between only supporting a limited number
of frameworks or creating a large number of adapter classes.

A common interface for caching systems will solve these problems. Library and
framework developers can count on the caching systems working the way they're
expecting, while the developers of caching systems will only have to implement
a single set of interfaces rather than a whole assortment of adapters.

### 1.2 Definitions

*    **TTL** - The Time To Live (TTL) of an item is the amount of time between
when that item is stored and it is considered stale. The TTL is normally defined
by an integer representing time in seconds.

*    **Expiration** - The actual time when an item is set to go stale.

    An item with a 300 second TTL stored at 1:30:00 will have an expiration at
    1:35:00.

*    **Key** - A string that uniquely identifies the cached item. Implementing
libraries are responsible for any encoding or escaping required by their
backends, but must be able to supply the original key if needed.

### 1.3 CacheItem

By `CacheItem` we refer to a object that implements the
`Psr\Cache\CacheItemInterface` interface.

By using the `CacheItem`, implementations can guarantee consistency across
various systems.

The `CacheItem` objects are generated by the `Cache` class. `CacheItem` objects
encapsulate the key and value of the stored cache entry.  `CacheItem` objects
SHOULD NOT be created in any other way.

### 1.4 Cache

By `Cache` we refer to a object that implements the `Psr\Cache\CacheInterface`
interface.

Implementations MAY provide a mechanism for a user to specify a default TTL
if one is not specified for a specific cache item.  If no user-specified default
is provided implementations MUST default to the maximum legal value allowed by
the underlying implementation.  If the underlying implementation does not
support TTL, the user-specified TTL MUST be silently ignored.

Implementations MUST accept keys that consist of up to 32 characters, containing
the ASCII values A-Z, z-z, 0-9, _, ., and -.  That is the minimum requirement
for keys is the regular expression [A-Z|a-z|0-9|\.|\-|\_]{1,32}.
Implementations MAY allow additional characters or extended ASCCI-compatible
character sets (such as UTF-8), but these characters MUST always be legal.

2. Interfaces
----------

### 2.1 CacheItem

```php

<?php

namespace Psr\Cache;

interface CacheItemInterface
{

    /**
     * Gets the key associated with this CacheItem.
     *
     * @return string
     */
    public function getKey();

    /**
     * Retrieves the stored value for this cache item.
     *
     * @return mixed  The saved value, or NULL if isHit() is False.
     */
    public function getValue();

    /**
     * Returns whether or not this was a cache hit.
     *
     * @return boolean  True if the cache request found a value, False otherwise.
     */
    public function isHit();

}

```

### 2.2 Cache

```php

<?php

namespace Psr\Cache;

use Psr\Cache\CacheItemInterface;

interface CacheInterface
{

    /**
     * Retrieves a value from the cache for the specified key.
     *
     * @param string $key The unique key of this item in the cache.
     *
     * @return CacheItemInterface The newly populated CacheItem class representing the stored data in the cache.
     */
    public function get($key);

    /**
     * Persists data in the cache by the specified key.
     *
     * @param string       $key   The key of the item to store.
     * @param mixed        $value The value of the item to store.
     * @param null|integer $ttl   Optional. The TTL value of this item. If not specified, it
     *                            will default to the longest legal value or a
     *                            previously-user-specified default value.
     *
     * @return boolean True if the value was successfully saved. False otherwise.
     */
    public function set($key, $value, $ttl = null);

    /**
     * Removes an item from the cache by its unique key.
     *
     * @param string $key The unique cache key of the item to remove.
     *
     * @return boolean    True if the value was removed or did not exist. False otherwise.
     */
    public function remove($key);

    /**
     * Retrieves multiple values from the cache for the specified keys.
     *
     * Note: The order of cache items returned is not guaranteed, and should not
     * be relied upon.
     *
     * @param array $keys A list of keys to retrieve.
     *
     * @return array An associative array of CacheItem objects, keyed by cache key.
     */
    public function getMultiple(array $keys);

    /**
     * Persists multiple items in the cache at once.
     *
     * @param array        $items An array of key => value pairs for a multiple-set operation.
     * @param null|integer $ttl   Optional. The TTL value of all items. If not specified, it
     *                            will default to the longest legal value or a
     *                            previously-user-specified default value.
     *
     * @return boolean True if all values were successfully saved. False otherwise.
     */
    public function setMultiple(array $items, $ttl = null);

    /**
     * Removes multiple cache items from the cache.
     *
     * @param array $keys The list of keys to be removed.
     *
     * @return array An array of 'key' => result, elements. Each array row has the key being deleted
     *               and the result of that operation. The result will be True if the value was
                     removed or did not exist or False otherwise.
     */
    public function removeMultiple(array $keys);

    /**
     * Removes all cache items from the system.
     *
     * @return boolean True if the clear command was successful, False otherwise.
     */
    public function clear();

}

```

3. Examples
-----------

* [PsrCacheItem](https://gist.github.com/dragoonis/3802de3d5780f19c81b6)
* [Redis](https://gist.github.com/dragoonis/ee20463da101cabc7354)
* [Memcached](https://gist.github.com/dragoonis/1c4ea0836097f5fd1fd6)
* [APC](https://gist.github.com/dragoonis/6b28ae75f141aab552e5)
* [DoctrineCache](https://gist.github.com/dragoonis/64e5f508caeb1792a8b3)

4. Package
----------

The interfaces described as well as a test suite to verify your implementation
are provided as part of the [psr/cache](https://packagist.org/packages/psr/cache) package.

5. Credits
----------

This proposal is the result of many months of deliberation, team work and proposals which can be referenced here:

 * https://github.com/tedivm/fig-standards/blob/Cache/proposed/PSR-Cache.md
 * https://github.com/evert/fig-standards/blob/master/proposed/objectcache.md
 * https://github.com/dlsniper/fig-standards/blob/cache-proposal/proposed/psr-cache.md
